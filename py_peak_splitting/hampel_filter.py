"""Hampel filter---------------------------------This is an implementation of a hampel filter based random telegraph noise removal tool; In which a hampel filter is used for the purpose of segment wise outlier detection in the sample-wise difference signal corresponding to the corrupted raw signal. Subsequently the detected outliers are replaced using a segment wise regression method. Once the detection and replacement are completed, the cumulative sum of the de-noised difference signal is computed to arrive at a de-noisedrealisation of the noisy time series."""# import section:import numpy as npclass Hampel(object):    """    Hampel filter    ---------------------------------    The Hampel class provides an implementation of a hampel filter for the purpose of outlier detection     and replacements in signals corrupted by peak splitting artefacts (multi levelrandom telegraph noise).    Artefacts are removed using a hampel filter method applied on the sample wise    difference signal.    :param arr: raw data containing jumps.     :type arr: np.ndarray of shape [N x 1]     :param th: threshold selction method: 'hard', 'med', 'sig'    :type th: string    :param th_val: threshold scale factor on threshold values which are dereived by methods; used a calibration parameter.    :type th_val: float    :param re: replacement method: 're', 'med', 'plf'    :type re: string    :param nperseg: number of samples per segment    :type nperseg: int    :param settings: optional dictionary containing settings for np.polyfit.    :type settings: dict    examples:    ---------------------------------            """    def __init__(self, arr, th='med', th_val=1.1, re='med', nperseg=25, settings=None, avoid_implosion=True):        """        Constructor method:         :param arr: raw data containing jumps.         :type arr: np.ndarray of shape [N x 1]         :param th: threshold selction method: 'hard', 'med', 'sig'        :type th: string        :param th_val: threshold scale factor on threshold values which are dereived by methods; used a calibration parameter.        :type th_val: float        :param re: replacement method: 're', 'med', 'plf'        :type re: string        :param nperseg: number of samples per segment        :type nperseg: int        :param settings: optional dictionary containing settings for np.polyfit.        :type settings: dict        :param avoid_implosion: switch for deciding wether additional median filter (static settings) should be applied on derived threshold levels        :type avoid_implosion: bool                """        # preallocate empty attr.        self.labels = None        self.th_arr = None        # from settings stings to methods:        self.arr = arr        self.th_val = th_val        self.nperseg = nperseg        self.avoid_implosion = avoid_implosion        self.th = eval('self._th_' + th)        self.re = eval('self._re_' + re)        self.settings = settings        # perform the reconstruction(s)        self.differences = np.hstack([0, np.diff(arr)])        self.differences = self.reconstruction_pipe(arr=self.differences, nperseg=nperseg)        self.reconstruction = np.cumsum(self.differences) + self.arr[0]        # clusters, counts, scores:        self.clusters = self._clusters()        self.counts = self._counts()        self.scores = self._scores()    # define segment-wise thresholds methods    # ===================================================    # methods to define the threshold value for outlier detection on each segment    def _th_hard(self, seg, th=0.25):        """ Use hard threshold to detect outliers.            :param seg: array of shape (# segments, nperseg)            :param th: threshold settings            :return: threshold level             :rtype: float        """        return th * np.ones((np.max(seg.shape),))    def _th_med(self, seg, th=1.15):        """ Use ... to detect outliers in segments.            :param seg: array of shape (# segments, nperseg)            :param th: threshold settings            :return: threshold level             :rtype: float        """        return th * np.median(seg, axis=1)    def _th_sig(self, seg, th=3):        """ Use the MAD scale estimate as intial threshold to detect outliers in segments.            :param seg: array of shape (# segments, nperseg)            :param th: threshold factor            :param avoid_implosion: bool/switch for using median filter to filter implosion sequences.            :return: threshold level             :rtype: float        """        # naive defintion of segment threshold levels based on MAD scale estimate         med = np.median(seg, axis=1)        med = np.reshape(med, (med.shape[0],1))        mad = np.median(np.abs(seg - med), axis=1)        mad = np.reshape(mad, (med.shape[0],1))        return th * 1.4826 * mad    # Median filter to prevent segments from imploding    # ===================================================    def _avoid_implosion(self, th, percentile_th=95, th_fact=2):        """ Use additional median filter to remove thresholds generated by potential implosive sequences.            :param th: threshold values per segment            :param percentile_th: percentile bound on MAD scale estimates            :param th_fact: scales percentile bound to arrive at final threhsold level which is used to filter out implosion sequences            :return: threshold level             :rtype: float        """        _th = th_fact*np.percentile(th, percentile_th)        th_med = np.median(th)        th[th>_th] = th_med        return th    # define replacement methods    # ===================================================    def _re_med(self, seg, th=None):        """ Use median from segment to replace outliers in segment.            :param seg: np.ndarray  of shape (# segments, nperseg)            :param th: threshold values per segment            :return:        """        # if th is None:        return np.median(seg, axis=1)        # else:        #    return np.asarray([np.median(s[np.abs(s) <= t]) for s, t in zip(seg, th)])    def _re_rnd(self, seg, th=None):        """ Use random draw from segment to replace outliers in segment.            :param seg: array of shape (# segments, nperseg)            :param th: threshold values per segment            :return:        """        if th is None:            return np.asarray([np.random.choice(s, 1) for s in seg])        else:            return np.asarray([np.random.choice(s[np.abs(s) <= t], 1) for s, t in zip(seg, th)])    def _re_plf(self, seg, th):        """ Use polyfit on segment to replace outliers in segment.            :param seg: array of shape (# segments, nperseg)            :param th: threshold values per segment            :return:        """        t = range(seg.shape[1])        t = np.asarray(t)        rep = np.copy(seg)        for r, th_val in zip(rep, th):            idx_i = np.abs(r) <= th_val            idx_o = np.abs(r) > th_val            if len(idx_o) > 0:                r = np.asarray(r)                if self.settings is not None:                    pfit = np.polyfit(t[idx_i], r[idx_i], self.settings)                else:                    pfit = np.polyfit(t[idx_i], r[idx_i], deg=1)                r[idx_o] = np.polyval(pfit, t[idx_o])        return rep    # reshape array into array  holding segments as rows    # ===================================================    def _seg_array(self, arr, nperseg):        """ Reshape arr into segments of length nperseg. Zero pad will be appended to the last segment in order to keep            the segment dimensions compatible.            :param arr: 1-dimensional input array of arbitrary length.            :param nperseg: length of segments.            :return: reshaped array holding segments as rows        """        data = arr.flatten()        nsegs = int(np.ceil(np.max(arr.shape) / nperseg))        data.resize((nsegs, nperseg))        return data    # Segments-wise processing of data    # ===================================================    def reconstruction_pipe(self, arr, nperseg, avoid_implosion=True):        """ Perform outlier detection and replacement on array. Segment array into shorter arrays.            find outliers in each segment using a "threshold method", and replace samples in each            segment using a "replacement method".            :param arr: 1-dimensional input array (the sample wise difference signal in this application).            :param nperseg: length of segments to be used for outlier detection and replacement.	    :param avoid_implosion: switch for deciding wether additional median filter should be applied on derived threshold levels            :return: reconstructed signal        """        # prepare data for processing:        seg_arr = self._seg_array(arr=arr, nperseg=nperseg)        th_arr = self.th(seg=seg_arr, th=self.th_val)        if self.avoid_implosion:                th_arr = self._avoid_implosion(th=th_arr)        re_arr = self.re(seg=seg_arr, th=th_arr)        # Outlier replacement        segs_new = np.asarray(list(map(lambda _s, _t, _r: np.where(np.abs(_s) > np.abs(_t), _r, _s),                                       seg_arr, th_arr, re_arr)))        rec = segs_new.flatten()        rec = rec[0:np.max(arr.shape)]        # setup labels from outlier detection:        labels_lst = list()        labels = np.asarray(list(map(lambda _s, _t: np.where(np.abs(_s) > np.abs(_t), -1, 0),                                     seg_arr, th_arr)))        labels = labels.flatten()        labels_lst.append(labels[0:np.max(arr.shape)])        self.labels = labels_lst        self.th_arr = th_arr        self.label_indices()        return rec    # some additional information which can be used for plotting    # ===================================================    def label_indices(self):        """ construct labels for samples: lists of indices corresponding to all inliers and outliers respectively.            :return: indices for in and outliers        """        idx_i = list()        idx_o = list()        for lab in self.labels:            idx_i.append((lab == -1).astype(bool))            idx_o.append((lab == 0).astype(bool))        self.idx_i = idx_i        self.idx_o = idx_o    def _clusters(self):        """ construct list of samples corresponding to all inliers and outliers respectively.            :return:        """        clusters = list()        for labels in self.labels:            clusters.append(                [[k for k, li in enumerate(labels.astype(list)) if li == lu] for lu in list(set(labels))])        return clusters    def _counts(self):        """ count inliers and outliers            :return: List containing counts of inliers and outliers        """        counts = [[len(cl) for cl in clusters] for clusters in self.clusters]        return counts    def _scores(self):        """ Compute ratio between outliers and the total amount of samples.            :return: List containing ratio between outliers and total number of samples        """        scores = [counts[1] / (counts[0] + counts[1]) if len(counts) > 1 else -1 for counts in self.counts]        return scores